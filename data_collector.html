<!--
================================================================================
TaijiFlow AI - Reference Data Collector (data_collector.html)
================================================================================

‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡πà‡∏≤‡∏°‡πâ‡∏ß‡∏ô‡πÑ‡∏´‡∏°‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á (Reference Path)

‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå:
  - ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÅ‡∏ö‡∏ö‡∏à‡∏≤‡∏Å‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡∏µ‡πà‡∏¢‡∏ß‡∏ä‡∏≤‡∏ç
  - ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå JSON ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô Reference Path ‡πÉ‡∏ô Main App
  - ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ WebM ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Backup

‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:
  1. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡πà‡∏≤‡∏ù‡∏∂‡∏Å (rh_cw, rh_ccw, lh_cw, lh_ccw)
  2. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡∏î‡∏±‡∏ö (L1: ‡∏ô‡∏±‡πà‡∏á, L2: ‡∏¢‡∏∑‡∏ô, L3: ‡∏¢‡∏∑‡∏ô‡∏¢‡πà‡∏≠)
  3. ‡∏Å‡∏î "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å" ‡πÅ‡∏•‡∏∞‡∏ô‡∏±‡∏ö‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á 3-2-1
  4. ‡∏ó‡∏≥‡∏ó‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö (30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
  5. ‡πÑ‡∏ü‡∏•‡πå JSON ‡πÅ‡∏•‡∏∞ WebM ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
  6. ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå JSON ‡πÑ‡∏õ‡∏ó‡∏µ‡πà /data/

‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á:
  1. HEAD: Styles + MediaPipe Scripts
  2. BODY:
     - Exercise/Level Selection
     - Status Bar: Recording indicator + Timer
     - Canvas Container: Video + Skeleton + Countdown
     - Filename Preview
     - Control Buttons: Start/Stop
     - Instructions

Optimizations:
  - ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏∏‡∏Å 3 frames (30fps ‚Üí 10fps) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå
  - ‡∏õ‡∏±‡∏î‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 3 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á (0.123 ‡πÅ‡∏ó‡∏ô 0.123456789)
  - Minify JSON (‡πÑ‡∏°‡πà‡∏°‡∏µ whitespace)

Output Files:
  - {exercise}_{level}.json: Landmarks data ‚Üí ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô Main App
  - {exercise}_{level}_{timestamp}.webm: Video backup

Version: 0.4 (2024-12-17)
================================================================================
-->
<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TaijiFlow AI - Reference Data Collector</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        background-color: #1a202c;
        color: white;
        font-family: "Sarabun", sans-serif;
      }
      .canvas-container {
        position: relative;
        width: 100%;
        max-width: 100%;
        aspect-ratio: 16/9;
        margin: 0 auto;
      }
      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
        object-fit: cover;
      }
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
        object-fit: cover;
      }
      .status-dot {
        height: 12px;
        width: 12px;
        border-radius: 50%;
        display: inline-block;
      }
      .recording {
        background-color: #ef4444;
        animation: pulse 1s infinite;
      }
      .idle {
        background-color: #9ca3af;
      }
      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }
      /* Countdown Overlay */
      .countdown-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        z-index: 20;
      }
      .countdown-overlay.hidden {
        display: none !important;
      }
      .countdown-number {
        font-size: 10rem;
        font-weight: bold;
        color: white;
        animation: pulse 1s infinite;
      }
    </style>
  </head>
  <body class="flex flex-col items-center justify-center min-h-screen p-4">
    <h1 class="text-3xl font-bold mb-4 text-purple-400">
      ‚òØÔ∏è TaijiFlow AI: Reference Data Collector
    </h1>

    <div
      class="bg-gray-800 p-6 rounded-lg shadow-lg text-center w-full max-w-6xl"
    >
      <!-- Exercise & Level Selection -->
      <div class="mb-4 flex justify-center gap-4 flex-wrap">
        <div>
          <label class="block text-sm text-gray-400 mb-1">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡πà‡∏≤‡∏ù‡∏∂‡∏Å:</label>
          <select
            id="exercise-select"
            class="px-4 py-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-purple-500 focus:outline-none"
          >
            <option value="rh_cw">‡∏°‡∏∑‡∏≠‡∏Ç‡∏ß‡∏≤ - ‡∏ï‡∏≤‡∏°‡πÄ‡∏Ç‡πá‡∏° (RH-CW)</option>
            <option value="rh_ccw">‡∏°‡∏∑‡∏≠‡∏Ç‡∏ß‡∏≤ - ‡∏ó‡∏ß‡∏ô‡πÄ‡∏Ç‡πá‡∏° (RH-CCW)</option>
            <option value="lh_cw">‡∏°‡∏∑‡∏≠‡∏ã‡πâ‡∏≤‡∏¢ - ‡∏ï‡∏≤‡∏°‡πÄ‡∏Ç‡πá‡∏° (LH-CW)</option>
            <option value="lh_ccw">‡∏°‡∏∑‡∏≠‡∏ã‡πâ‡∏≤‡∏¢ - ‡∏ó‡∏ß‡∏ô‡πÄ‡∏Ç‡πá‡∏° (LH-CCW)</option>
          </select>
        </div>
        <div>
          <label class="block text-sm text-gray-400 mb-1">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡∏î‡∏±‡∏ö:</label>
          <select
            id="level-select"
            class="px-4 py-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-purple-500 focus:outline-none"
          >
            <option value="L1">Level 1: ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πà‡∏á</option>
            <option value="L2">Level 2: ‡∏ó‡πà‡∏≤‡∏¢‡∏∑‡∏ô</option>
            <option value="L3">Level 3: ‡∏ó‡πà‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡πà‡∏≠</option>
          </select>
        </div>
      </div>

      <!-- Status Bar -->
      <div class="mb-4 flex justify-between items-center">
        <span id="statusText" class="text-gray-400">‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</span>
        <div class="flex items-center gap-2">
          <span id="recordIndicator" class="status-dot idle"></span>
          <span id="timer" class="font-mono text-xl">00:00</span>
          <span class="text-gray-500 text-sm">/ 00:30</span>
        </div>
      </div>

      <!-- Canvas Container -->
      <div
        class="canvas-container bg-black rounded overflow-hidden shadow-xl mb-6"
      >
        <video id="input_video" style="display: none"></video>
        <canvas id="output_canvas" width="1280" height="720"></canvas>

        <!-- Countdown Overlay (hidden by default) -->
        <div id="countdown-overlay" class="countdown-overlay hidden">
          <span id="countdown-number" class="countdown-number">3</span>
        </div>
      </div>

      <!-- Filename Preview -->
      <div class="mb-4 p-3 bg-gray-700 rounded text-left">
        <span class="text-gray-400">üìÅ ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å: </span>
        <span id="filename-preview" class="text-green-400 font-mono"
          >rh_cw_L1.json</span
        >
      </div>

      <!-- Control Buttons -->
      <div class="space-x-4">
        <button
          id="startBtn"
          onclick="startRecordingWithCountdown()"
          class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg transition text-lg"
        >
          üî¥ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å (3-2-1)
        </button>
        <button
          id="stopBtn"
          onclick="stopRecording()"
          class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-8 rounded-lg transition text-lg opacity-50 cursor-not-allowed"
          disabled
        >
          ‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î & ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
        </button>
      </div>

      <!-- Instructions -->
      <div
        class="mt-6 p-4 bg-purple-900 bg-opacity-30 rounded border border-purple-700 text-left"
      >
        <h3 class="text-purple-300 font-bold mb-2">üí° ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å:</h3>
        <ul class="list-disc list-inside text-gray-300 text-sm space-y-1">
          <li>‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡πà‡∏≤‡∏•‡∏∞ <strong>30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ</strong> (‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏´‡∏¢‡∏∏‡∏î‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)</li>
          <li>‡∏ó‡∏≥‡∏ó‡πà‡∏≤‡πÉ‡∏´‡πâ <strong>‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏ö‡∏ö</strong> ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏ô‡πÅ‡∏ö‡∏ö</li>
          <li>‡∏¢‡∏∑‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡πá‡∏°‡∏ï‡∏±‡∏ß ‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á 2-3 ‡πÄ‡∏°‡∏ï‡∏£</li>
          <li>
            ‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô
            <code class="bg-gray-700 px-1 rounded"
              >{exercise}_{level}.json</code
            >
          </li>
          <li>
            ‡∏´‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ‡πÉ‡∏´‡πâ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
            <code class="bg-gray-700 px-1 rounded">data/</code>
          </li>
        </ul>
      </div>
    </div>

    <script>
      // =============================================================
      // Configuration
      // =============================================================
      const MAX_RECORDING_SECONDS = 30; // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å 30 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
      const COUNTDOWN_SECONDS = 3; // ‡∏ô‡∏±‡∏ö‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á 3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ

      // =============================================================
      // DOM Elements
      // =============================================================
      const videoElement = document.getElementById("input_video");
      const canvasElement = document.getElementById("output_canvas");
      const canvasCtx = canvasElement.getContext("2d");
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const statusText = document.getElementById("statusText");
      const recordIndicator = document.getElementById("recordIndicator");
      const timerDisplay = document.getElementById("timer");
      const exerciseSelect = document.getElementById("exercise-select");
      const levelSelect = document.getElementById("level-select");
      const filenamePreview = document.getElementById("filename-preview");
      const countdownOverlay = document.getElementById("countdown-overlay");
      const countdownNumber = document.getElementById("countdown-number");

      // =============================================================
      // State Variables
      // =============================================================
      let isRecording = false;
      let recordedLandmarks = [];
      let mediaRecorder;
      let recordedChunks = [];
      let startTime;
      let timerInterval;
      let frameCounter = 0; // For frame rate optimization (record every 3rd frame)

      // Silhouette Recording
      let silhouetteMediaRecorder;
      let silhouetteChunks = [];
      const silhouetteCanvas = document.createElement("canvas");
      silhouetteCanvas.width = 1280;
      silhouetteCanvas.height = 720;
      const silhouetteCtx = silhouetteCanvas.getContext("2d");

      // =============================================================
      // Update Filename Preview when selection changes
      // =============================================================
      function updateFilenamePreview() {
        const exercise = exerciseSelect.value;
        const level = levelSelect.value;
        filenamePreview.textContent = `${exercise}_${level}.json`;
      }

      exerciseSelect.addEventListener("change", updateFilenamePreview);
      levelSelect.addEventListener("change", updateFilenamePreview);
      updateFilenamePreview(); // Initial update

      // =============================================================
      // MediaPipe Pose Setup
      // =============================================================
      const pose = new Pose({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
        },
      });

      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: true, // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ segmentation mask ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö silhouette
        smoothSegmentation: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      pose.onResults(onResults);

      // =============================================================
      // Camera Setup (HD 1280x720)
      // =============================================================
      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await pose.send({ image: videoElement });
        },
        width: 1280,
        height: 720,
      });
      camera.start();

      // =============================================================
      // Pose Results Handler
      // =============================================================
      function onResults(results) {
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(
          results.image,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );

        if (results.poseLandmarks) {
          // ‡∏ß‡∏≤‡∏î skeleton
          drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {
            color: "#00FF00",
            lineWidth: 4,
          });
          drawLandmarks(canvasCtx, results.poseLandmarks, {
            color: "#FF0000",
            lineWidth: 2,
          });

          // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å landmarks ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á recording
          if (isRecording) {
            // Optimization 1: ‡πÄ‡∏Å‡πá‡∏ö‡∏ó‡∏∏‡∏Å 3 frames (‡∏•‡∏î‡∏à‡∏≤‡∏Å 30fps ‡πÄ‡∏õ‡πá‡∏ô 10fps)
            frameCounter++;
            if (frameCounter % 3 !== 0) {
              canvasCtx.restore();
              return; // Skip this frame
            }

            // Optimization 2: ‡∏õ‡∏±‡∏î‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 3 ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á (0.123456789 -> 0.123)
            const roundedLandmarks = results.poseLandmarks.map((lm) => ({
              x: Math.round(lm.x * 1000) / 1000,
              y: Math.round(lm.y * 1000) / 1000,
              z: Math.round(lm.z * 1000) / 1000,
              visibility: Math.round(lm.visibility * 1000) / 1000,
            }));

            recordedLandmarks.push({
              timestamp: Date.now() - startTime,
              landmarks: roundedLandmarks,
            });

            // ‡∏ß‡∏≤‡∏î Silhouette ‡∏•‡∏á offscreen canvas (‡∏Ç‡∏≤‡∏ß‡∏ö‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏î‡∏≥)
            if (results.segmentationMask) {
              silhouetteCtx.clearRect(
                0,
                0,
                silhouetteCanvas.width,
                silhouetteCanvas.height
              );
              silhouetteCtx.fillStyle = "black";
              silhouetteCtx.fillRect(
                0,
                0,
                silhouetteCanvas.width,
                silhouetteCanvas.height
              );

              // ‡∏ß‡∏≤‡∏î segmentation mask ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß
              silhouetteCtx.globalCompositeOperation = "source-over";
              silhouetteCtx.drawImage(
                results.segmentationMask,
                0,
                0,
                silhouetteCanvas.width,
                silhouetteCanvas.height
              );
            }
          }
        }
        canvasCtx.restore();
      }

      // =============================================================
      // Countdown Function
      // =============================================================
      function showCountdown() {
        return new Promise((resolve) => {
          countdownOverlay.classList.remove("hidden");
          let count = COUNTDOWN_SECONDS;
          countdownNumber.textContent = count;

          const interval = setInterval(() => {
            count--;
            if (count > 0) {
              countdownNumber.textContent = count;
            } else {
              clearInterval(interval);
              countdownOverlay.classList.add("hidden");
              resolve();
            }
          }, 1000);
        });
      }

      // =============================================================
      // Start Recording (with Countdown)
      // =============================================================
      async function startRecordingWithCountdown() {
        // Disable start button immediately
        startBtn.disabled = true;
        startBtn.classList.add("opacity-50", "cursor-not-allowed");
        statusText.innerText = "‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏ï‡∏±‡∏ß...";

        // Show countdown
        await showCountdown();

        // Start actual recording
        startRecording();
      }

      function startRecording() {
        isRecording = true;
        recordedLandmarks = [];
        recordedChunks = [];
        frameCounter = 0; // Reset frame counter

        // Video recording at 30 FPS
        const stream = canvasElement.captureStream(30);
        let options = { mimeType: "video/webm;codecs=vp9" };
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
          options = { mimeType: "video/webm" };
        }

        mediaRecorder = new MediaRecorder(stream, options);
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) recordedChunks.push(event.data);
        };
        mediaRecorder.start();

        // Silhouette recording at 30 FPS
        silhouetteChunks = [];
        const silhouetteStream = silhouetteCanvas.captureStream(30);
        console.log(
          "üìä silhouetteStream tracks:",
          silhouetteStream.getTracks().length
        );

        silhouetteMediaRecorder = new MediaRecorder(silhouetteStream, options);
        silhouetteMediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) silhouetteChunks.push(event.data);
        };
        silhouetteMediaRecorder.start();
        console.log(
          "‚úÖ silhouetteMediaRecorder started, state:",
          silhouetteMediaRecorder.state
        );

        startTime = Date.now();
        stopBtn.disabled = false;
        stopBtn.classList.remove("opacity-50", "cursor-not-allowed");
        statusText.innerText = "üî¥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å...";
        statusText.classList.add("text-red-400");
        recordIndicator.classList.remove("idle");
        recordIndicator.classList.add("recording");

        // Timer with auto-stop at MAX_RECORDING_SECONDS
        timerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(elapsed / 60)
            .toString()
            .padStart(2, "0");
          const seconds = (elapsed % 60).toString().padStart(2, "0");
          timerDisplay.innerText = `${minutes}:${seconds}`;

          // Auto-stop at max duration
          if (elapsed >= MAX_RECORDING_SECONDS) {
            stopRecording();
          }
        }, 1000);
      }

      // =============================================================
      // Stop Recording
      // =============================================================
      function stopRecording() {
        if (!isRecording) return;

        isRecording = false;
        clearInterval(timerInterval);
        statusText.innerText = "‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå...";

        // ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏ó‡∏±‡πâ‡∏á 2 recorders ‡∏´‡∏¢‡∏∏‡∏î‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡∏Å‡πà‡∏≠‡∏ô download
        let stoppedCount = 0;

        function onRecorderStopped() {
          stoppedCount++;
          console.log(`üìä Recorder stopped: ${stoppedCount}/2`);
          if (stoppedCount === 2) {
            // ‡∏ó‡∏±‡πâ‡∏á 2 recorder ‡∏´‡∏¢‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß ‡∏à‡∏∂‡∏á download
            downloadData();
            resetUI();
          }
        }

        mediaRecorder.onstop = onRecorderStopped;
        silhouetteMediaRecorder.onstop = onRecorderStopped;

        mediaRecorder.stop();
        silhouetteMediaRecorder.stop();
      }

      // =============================================================
      // Download Data Files
      // =============================================================
      function downloadData() {
        const exercise = exerciseSelect.value;
        const level = levelSelect.value;

        console.log("üìä Debug - recordedChunks:", recordedChunks.length);
        console.log("üìä Debug - silhouetteChunks:", silhouetteChunks.length);

        // 1. Download JSON (Landmarks) - ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏≤‡∏°‡∏ó‡πà‡∏≤‡πÅ‡∏•‡∏∞‡∏£‡∏∞‡∏î‡∏±‡∏ö
        const jsonString = JSON.stringify(recordedLandmarks);
        const jsonBlob = new Blob([jsonString], { type: "application/json" });
        const jsonUrl = URL.createObjectURL(jsonBlob);
        const jsonLink = document.createElement("a");
        jsonLink.href = jsonUrl;
        jsonLink.download = `${exercise}_${level}.json`;
        jsonLink.click();

        // 2. Download Original Video (WebM) - delay ‡πÄ‡∏û‡∏∑‡πà‡∏≠ browser ‡πÑ‡∏°‡πà block
        setTimeout(() => {
          if (recordedChunks.length > 0) {
            const videoBlob = new Blob(recordedChunks, { type: "video/webm" });
            const videoUrl = URL.createObjectURL(videoBlob);
            const videoLink = document.createElement("a");
            videoLink.href = videoUrl;
            videoLink.download = `${exercise}_${level}.webm`;
            videoLink.click();
            console.log("‚úÖ Downloaded original video");
          } else {
            console.warn("‚ö†Ô∏è No video chunks!");
          }
        }, 500);

        // 3. Download Silhouette Video (WebM) - delay ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
        setTimeout(() => {
          if (silhouetteChunks.length > 0) {
            const silhouetteBlob = new Blob(silhouetteChunks, {
              type: "video/webm",
            });
            const silhouetteUrl = URL.createObjectURL(silhouetteBlob);
            const silhouetteLink = document.createElement("a");
            silhouetteLink.href = silhouetteUrl;
            silhouetteLink.download = `${exercise}_${level}_silhouette.webm`;
            silhouetteLink.click();
            console.log("‚úÖ Downloaded silhouette video");
          } else {
            console.warn("‚ö†Ô∏è No silhouette chunks!");
          }
        }, 1000);

        console.log(
          `‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏™‡∏£‡πá‡∏à: ${exercise}_${level} (${recordedLandmarks.length} frames)`
        );
      }

      // =============================================================
      // Reset UI
      // =============================================================
      function resetUI() {
        startBtn.disabled = false;
        startBtn.classList.remove("opacity-50", "cursor-not-allowed");
        stopBtn.disabled = true;
        stopBtn.classList.add("opacity-50", "cursor-not-allowed");
        statusText.innerText = "‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô! ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡πà‡∏≤‡∏ñ‡∏±‡∏î‡πÑ‡∏õ";
        statusText.classList.remove("text-red-400");
        statusText.classList.add("text-green-400");
        recordIndicator.classList.remove("recording");
        recordIndicator.classList.add("idle");
        timerDisplay.innerText = "00:00";

        // Reset status color after 3 seconds
        setTimeout(() => {
          statusText.classList.remove("text-green-400");
          statusText.innerText = "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å";
        }, 3000);
      }
    </script>
  </body>
</html>
